# Task 2.20-2.21: Address Component Value Objects - REFACTORED

**Status:** ✅ Completed (Refactored with Generic Validation Rules)  
**Commit:** TBD  
**Related:** [PRD-0001](../../../tasks/0001-prd-register-user.md), [Tasks](../../../tasks/tasks-0001-prd-register-user.md)

---

## Overview

Implementation of four address component value objects (`Street`, `City`, `PostalCode`, `Country`) with a **refactored validation approach** using generic, reusable validation rules instead of inline validation logic.

**Key Design Changes:**

1. ✅ **Generic Validation Rules:** `NotEmptyRule<TValue>` and `MaxLengthRule<TValue>` replace inline if-statements
2. ✅ **IValidationRule<TValue>:** Type-safe validation rules for specific value objects (e.g., `IValidationRule<Street>`)
3. ✅ **DRY Principle:** Validation logic centralized in reusable rule classes
4. ✅ **RuleComposer Pattern:** Combines multiple rules with short-circuit evaluation
5. ✅ **Elimination of Code Duplication:** Removed ~20 lines of duplicate code per factory

---

## Architecture Evolution

### Before: Inline Validation (Initial Implementation)

```csharp
public static class StreetFactory
{
    private const int MaxLength = 200;

    public static Result<Street> Create(string value)
    {
        // ❌ Inline validation - repeated in every factory
        if (string.IsNullOrWhiteSpace(value))
            return CreateError(nameof(Street.Value), "Street cannot be empty");
        
        if (value.Length > MaxLength)
            return CreateError(nameof(Street.Value), 
                $"Street cannot exceed maximum length of {MaxLength} characters");
        
        Street street = new(value);
        
        // Assertions...
        return ResultFactory.Success(street);
    }
    
    // ❌ Duplicate helper method in every factory
    private static Result<Street> CreateError(string propertyName, string message)
    {
        Error error = ErrorFactory.Validation(propertyName, message);
        Result<Street> failure = ResultFactory.Failure<Street>(error);
        Debug.Assert(failure.IsFailure, "Result should be a failure");
        return failure;
    }
}
```

**Problems:**

- Same validation logic repeated 4 times (Street, City, PostalCode, Country)
- `CreateError` helper duplicated in every factory
- Hard to test validation rules in isolation
- Cannot reuse validation for future value objects

### After: Generic Validation Rules (Refactored)

```csharp
// ✅ Generic reusable validation rule
public sealed class NotEmptyRule<TValue>(Func<TValue, string> selector) 
    : IValidationRule<TValue>
    where TValue : class
{
    public Result Validate(TValue value)
    {
        string input = selector.Invoke(value);

        if (string.IsNullOrWhiteSpace(input))
            return ResultFactory.Failure(
                ErrorFactory.Validation(
                    typeof(TValue).Name,
                    $"{typeof(TValue).Name} cannot be empty"
                )
            );

        return ResultFactory.Success();
    }
}

// ✅ Factory uses composable rules
public static class StreetFactory
{
    private const int MaxLength = 200;

    public static Result<Street> Create(string value, IValidationRule<Street>[]? rules = null)
    {
        Street street = new(value);

        // Default rules if none provided
        rules ??= [
            new NotEmptyRule<Street>(s => s.Value),
            new MaxLengthRule<Street>(s => s.Value, MaxLength)
        ];

        Debug.Assert(rules.Length > 0, "At least 1 validation rule must be provided");

        // Compose and validate
        RuleComposer<Street> composedRule = RuleComposerFactory.Create(rules);
        Result validationResult = composedRule.Validate(street);

        if (validationResult is Failure failure)
        {
            Result<Street> failureResult = ResultFactory.Failure<Street>(failure.Error);
            Debug.Assert(failureResult.IsFailure, "Result should be a failure");
            return failureResult;
        }

        // NASA assertions
        Debug.Assert(rules.Length >= 2, "At least 2 validation rules must be provided");
        Debug.Assert(
            !string.IsNullOrWhiteSpace(street.Value),
            "Street value must not be empty after creation"
        );
        Debug.Assert(
            street.Value.Length <= MaxLength,
            "Street value must not exceed maximum length after creation"
        );

        Result<Street> success = ResultFactory.Success(street);
        Debug.Assert(success.IsSuccess, "Result should be a success");
        Debug.Assert(success.Value == street, "Result value should be the created street");

        return success;
    }
}
```

**Benefits:**

- ✅ Validation logic in one place (`NotEmptyRule<T>`, `MaxLengthRule<T>`)
- ✅ Testable in isolation (8 dedicated rule tests)
- ✅ Reusable for all current and future value objects
- ✅ Type-safe: `IValidationRule<Street>` not `IValidationRule<string>`
- ✅ Eliminated ~80 lines of duplicate code (4 factories × ~20 lines each)

---

## Generic Validation Rules

### 1. NotEmptyRule<TValue>

**File:** `src/UserManagement.Domain/Validation/Common/NotEmptyRule.cs`

**Purpose:** Validates that a string property of a value object is not null, empty, or whitespace

**Type Parameter:**

- `TValue where TValue : class` - The value object type (e.g., `Street`, `City`)

**Constructor:**

```csharp
public NotEmptyRule(Func<TValue, string> selector)
```

- `selector`: Function to extract the string property from the value object

**Behavior:**

- Invokes selector to get string value
- Checks `string.IsNullOrWhiteSpace()`
- Returns `Failure` with error code `{TypeName}.Validation` and message `"{TypeName} cannot be empty"`
- Uses `typeof(TValue).Name` to get actual type name at runtime

**Example Usage:**

```csharp
// For Street value object
var rule = new NotEmptyRule<Street>(s => s.Value);
Result result = rule.Validate(new Street("Main St")); // Success

// For City value object
var rule = new NotEmptyRule<City>(c => c.Value);
Result result = rule.Validate(new City("")); // Failure: "City cannot be empty"
```

**Tests:** 4 tests in `NotEmptyRuleTests.cs`

- ✅ `Validate_WithNonEmptyValue_ShouldSucceed`
- ✅ `Validate_WithEmptyValue_ShouldFail`
- ✅ `Validate_WithWhitespaceValue_ShouldFail`
- ✅ `Validate_WithNullValue_ShouldFail`

### 2. MaxLengthRule<TValue>

**File:** `src/UserManagement.Domain/Validation/Common/MaxLengthRule.cs`

**Purpose:** Validates that a string property of a value object does not exceed a maximum length

**Type Parameter:**

- `TValue where TValue : class` - The value object type

**Constructor:**

```csharp
public MaxLengthRule(Func<TValue, string> selector, int maxLength)
```

- `selector`: Function to extract the string property
- `maxLength`: Maximum allowed length

**Behavior:**

- Invokes selector to get string value
- Checks `value.Length > maxLength`
- Returns `Failure` with error code `{TypeName}.Validation` and message `"{TypeName} cannot exceed maximum length of {maxLength} characters"`

**Example Usage:**

```csharp
// For Street value object (max 200)
var rule = new MaxLengthRule<Street>(s => s.Value, 200);
Result result = rule.Validate(new Street(new string('a', 201))); // Failure

// For City value object (max 100)
var rule = new MaxLengthRule<City>(c => c.Value, 100);
Result result = rule.Validate(new City("New York")); // Success
```

**Tests:** 4 tests in `MaxLengthRuleTests.cs`

- ✅ `Validate_WithinMaxLength_ShouldSucceed`
- ✅ `Validate_AtExactMaxLength_ShouldSucceed`
- ✅ `Validate_ExceedingMaxLength_ShouldFail`
- ✅ `Validate_WithEmptyValue_ShouldSucceed` (empty is allowed, handled by NotEmptyRule)

---

## Refactored Components

### 1. Street Value Object

**File:** `src/UserManagement.Domain/ValueObjects/AddressComponents/Street.cs`

**Namespace:** `UserManagement.Domain.ValueObjects.AddressComponents`

**Changes:**

- ✅ Factory signature: `Create(string value, IValidationRule<Street>[]? rules = null)`
- ✅ Uses `NotEmptyRule<Street>` and `MaxLengthRule<Street>`
- ✅ Error code changed from `VALUE.Validation` to `STREET.Validation`
- ✅ Removed inline if-statements
- ✅ Removed `CreateError` helper method

**Default Rules:**

```csharp
rules ??= [
    new NotEmptyRule<Street>(s => s.Value),
    new MaxLengthRule<Street>(s => s.Value, 200)
];
```

### 2. City Value Object

**File:** `src/UserManagement.Domain/ValueObjects/AddressComponents/City.cs`

**Changes:**

- ✅ Factory signature: `Create(string value, IValidationRule<City>[]? rules = null)`
- ✅ Uses `NotEmptyRule<City>` and `MaxLengthRule<City>`
- ✅ Error code changed from `VALUE.Validation` to `CITY.Validation`

**Default Rules:**

```csharp
rules ??= [
    new NotEmptyRule<City>(c => c.Value),
    new MaxLengthRule<City>(c => c.Value, 100)
];
```

### 3. PostalCode Value Object

**File:** `src/UserManagement.Domain/ValueObjects/AddressComponents/PostalCode.cs`

**Changes:**

- ✅ Factory signature: `Create(string value, IValidationRule<PostalCode>[]? rules = null)`
- ✅ Uses `NotEmptyRule<PostalCode>` and `MaxLengthRule<PostalCode>`
- ✅ Error code changed from `VALUE.Validation` to `POSTALCODE.Validation`

**Default Rules:**

```csharp
rules ??= [
    new NotEmptyRule<PostalCode>(p => p.Value),
    new MaxLengthRule<PostalCode>(p => p.Value, 20)
];
```

### 4. Country Value Object

**File:** `src/UserManagement.Domain/ValueObjects/AddressComponents/Country.cs`

**Changes:**

- ✅ Factory signature: `Create(string value, IValidationRule<Country>[]? rules = null)`
- ✅ Uses `NotEmptyRule<Country>` and `MaxLengthRule<Country>`
- ✅ Error code changed from `VALUE.Validation` to `COUNTRY.Validation`

**Default Rules:**

```csharp
rules ??= [
    new NotEmptyRule<Country>(c => c.Value),
    new MaxLengthRule<Country>(c => c.Value, 100)
];
```

---

## Email Value Object Refactoring

**File:** `src/UserManagement.Domain/ValueObjects/Email.cs`

**Namespace Change:** `UserManagement.Domain.ValueObjects.Email` → `UserManagement.Domain.ValueObjects.Emails` (with 's')

**Reason:** Avoid namespace conflict with `UserManagement.Domain.Validation.Email`

**Changes:**

- ✅ Namespace: `UserManagement.Domain.ValueObjects.Emails`
- ✅ Factory signature: `Create(string value, IValidationRule<Email>[]? rules = null)`
- ✅ `EmailValidationRuleBase` changed from `IValidationRule<string>` to `IValidationRule<Email>`
- ✅ All 13 email validation rules now validate `Email` objects instead of strings
- ✅ Default rules provided (all 13 email-specific rules)

**Email Validation Rules Updated:**

All now implement `IValidationRule<Email>` and validate `Email` objects:

1. ✅ `EmailNotEmptyRule`
2. ✅ `ExactlyOneAtSymbolRule`
3. ✅ `NoWhitespaceRule`
4. ✅ `NoNewlineCharactersRule`
5. ✅ `NoTrailingDotRule`
6. ✅ `DomainNotEmptyRule`
7. ✅ `DomainNotStartWithDotRule`
8. ✅ `NoConsecutiveDotsInDomainRule`
9. ✅ `ValidDomainHyphensRule`
10. ✅ `NoUnderscoreInDomainRule`
11. ✅ `LocalPartMaxLengthRule`
12. ✅ `DomainPartMaxLengthRule`
13. ✅ `DomainLabelMaxLengthRule`

**Example:**

```csharp
public sealed class EmailNotEmptyRule : EmailValidationRuleBase
{
    protected override string ErrorMessage => "Email cannot be empty";

    // Before: public override Result Validate(string value)
    // After:
    public override Result Validate(Email email) =>
        string.IsNullOrWhiteSpace(email.Value) ? CreateFailure() : CreateSuccess();
}
```

---

## Test Updates

### Address Components Tests

**Total:** 41 tests (10-11 per component)

**Changes:**

- ✅ Updated error code assertions from `VALUE.Validation` to specific codes:
  - `STREET.Validation`
  - `CITY.Validation`
  - `POSTALCODE.Validation`
  - `COUNTRY.Validation`
- ✅ All tests still passing

### Validation Rules Tests

**New Tests:** 8 tests total

**Files:**

- `tests/Tests.UserManagement.Domain/Validation/Common/NotEmptyRuleTests.cs` (4 tests)
- `tests/Tests.UserManagement.Domain/Validation/Common/MaxLengthRuleTests.cs` (4 tests)

### Email Tests

**Total:** Unchanged (existing email tests)

**Changes:**

- ✅ Updated to use `IValidationRule<Email>` instead of `IValidationRule<string>`
- ✅ Helper classes `AlwaysValidRule` and `AlwaysInvalidRule` now implement `IValidationRule<Email>`
- ✅ `EmailValidationRulesTests` uses alias `using EmailVO = UserManagement.Domain.ValueObjects.Emails.Email;` to avoid namespace conflict

**Total Tests:** 144 tests passing

---

## Architectural Decisions

### Why Generic Validation Rules?

**Problem:** Code duplication across value object factories

```csharp
// ❌ Before: Repeated in 4 factories
if (string.IsNullOrWhiteSpace(value))
    return CreateError(nameof(Street.Value), "Street cannot be empty");

if (value.Length > MaxLength)
    return CreateError(nameof(Street.Value), 
        $"Street cannot exceed maximum length of {MaxLength} characters");
```

**Solution:** Generic reusable rules

```csharp
// ✅ After: Write once, use everywhere
public sealed class NotEmptyRule<TValue>(Func<TValue, string> selector) 
    : IValidationRule<TValue>
```

**Benefits:**

1. **DRY Principle:** Validation logic in one place
2. **Testability:** Rules tested in isolation
3. **Reusability:** Works for all current and future value objects
4. **Type Safety:** `IValidationRule<Street>` not `IValidationRule<string>`
5. **Maintainability:** Change validation logic once, applies everywhere

### Why IValidationRule<TValue> Instead of IValidationRule<string>?

**Before: Generic String Validation**

```csharp
public sealed class NotEmptyStringRule : IValidationRule<string>
{
    public Result Validate(string value) { /* ... */ }
}

// Usage
IValidationRule<string>[] rules = [new NotEmptyStringRule()];
```

**Problems:**

- Not domain-specific
- Cannot access value object properties
- Less type-safe

**After: Type-Specific Validation**

```csharp
public sealed class NotEmptyRule<TValue> : IValidationRule<TValue>
    where TValue : class
{
    public Result Validate(TValue value) { /* ... */ }
}

// Usage
IValidationRule<Street>[] rules = [new NotEmptyRule<Street>(s => s.Value)];
```

**Benefits:**

- Type-safe at compile time
- Can access full value object if needed
- Clear intent: validating `Street`, not just a string
- Follows same pattern as `Email` validation

### Why typeof(TValue).Name Instead of nameof(TValue)?

**Problem with nameof():**

```csharp
nameof(TValue) // Always returns "TValue" (generic parameter name)
```

**Solution with typeof().Name:**

```csharp
typeof(TValue).Name // Returns "Street", "City", "PostalCode", etc. at runtime
```

**Benefit:** Error messages show actual type name, not generic parameter name

### Why Optional rules Parameter with Default Rules?

**Design:**

```csharp
public static Result<Street> Create(string value, IValidationRule<Street>[]? rules = null)
{
    rules ??= [/* default rules */];
    // ...
}
```

**Benefits:**

1. **Convenience:** Most calls use default rules
2. **Flexibility:** Tests can inject custom rules
3. **Extensibility:** Future rules can be added without breaking existing code

**Usage:**

```csharp
// Default rules
var result = StreetFactory.Create("Main St");

// Custom rules (testing)
var rules = new IValidationRule<Street>[] { new AlwaysValidRule() };
var result = StreetFactory.Create("", rules);
```

### Why Move Validation Rules from Application to Domain?

**Initial Mistake:** Rules created in `UserManagement.Application/Validation/Common/`

**Problem:** Circular dependency

- Domain layer needs validation rules
- Application layer depends on Domain layer
- Domain cannot depend on Application (violates Clean Architecture)

**Solution:** Move to Domain layer

- Rules moved to `UserManagement.Domain/Validation/Common/`
- Domain layer owns its validation logic
- Application layer can still use rules (no circular dependency)

**Clean Architecture Layers:**

```
Application ──depends on──> Domain
                            ↑
                            │
                   Validation rules belong here
```

---

## Integration Points

### Current Usage

- ✅ Street, City, PostalCode, Country value objects
- ✅ Email value object (refactored)
- ✅ Generic validation rules (NotEmptyRule, MaxLengthRule)

### Future Usage

#### 1. Address Entity (Task 2.25-2.28)

Will use refactored address components with type-safe validation

#### 2. Future Value Objects

Can reuse generic validation rules:

```csharp
// Future value object
public sealed record PhoneNumber(string Value);

public static class PhoneNumberFactory
{
    public static Result<PhoneNumber> Create(
        string value, 
        IValidationRule<PhoneNumber>[]? rules = null)
    {
        PhoneNumber phone = new(value);

        rules ??= [
            new NotEmptyRule<PhoneNumber>(p => p.Value),
            new MaxLengthRule<PhoneNumber>(p => p.Value, 20),
            new PhoneNumberFormatRule() // Custom rule
        ];

        // Same pattern as Street/City/PostalCode/Country
    }
}
```

---

## Benefits Summary

### 1. Code Reduction

- **Before:** ~120 lines of duplicate validation logic
- **After:** ~40 lines of generic validation rules
- **Savings:** ~80 lines eliminated

### 2. Maintainability

- Validation logic centralized
- Change once, applies everywhere
- Easy to add new rules

### 3. Testability

- Rules tested in isolation (8 dedicated tests)
- Value objects tested with default rules (41 tests)
- Clear separation of concerns

### 4. Type Safety

- `IValidationRule<Street>` not `IValidationRule<string>`
- Compiler prevents mixing different value object types
- Runtime type names in error messages

### 5. Reusability

- Same rules used by 4 address components
- Can be used by future value objects
- Follows OCP (Open/Closed Principle)

### 6. Consistency

- All value objects follow same pattern
- Same validation behavior
- Predictable API

---

## Related Documentation

- [Clean Architecture Overview](../00-clean-architecture.md)
- [Railway-Oriented Programming](../20-railway-oriented-programming.md)
- [Value Objects Pattern](../21-value-objects.md)
- [Factory Pattern](../22-factory-pattern.md)
- [Generic Validation Rules](./generic-validation-rules.md)
- [Email Value Object](./2.08-2.11-email.md)

---

## Summary

The **Address Component Value Objects Refactoring** demonstrates:

- **Generic Validation Rules:** Reusable `NotEmptyRule<T>` and `MaxLengthRule<T>`
- **Type Safety:** `IValidationRule<Street>` not `IValidationRule<string>`
- **DRY Principle:** Eliminated ~80 lines of duplicate code
- **Clean Architecture:** Validation rules in Domain layer, not Application
- **Testability:** Rules and value objects tested independently
- **Consistency:** Same pattern across all value objects (including Email)

**Key Takeaway:** Generic validation rules provide reusability without sacrificing type safety. By using `IValidationRule<TValue>` with selector functions, we achieve both DRY and type-safe validation.

**Total Implementation:**

- 2 Generic Validation Rules (NotEmptyRule<T>, MaxLengthRule<T>)
- 4 Refactored Value Objects (Street, City, PostalCode, Country)
- 1 Refactored Email Value Object (namespace changed, type-safe validation)
- 8 New Validation Rule Tests
- 41 Updated Address Component Tests
- **144 Tests Total - All Passing** ✅
